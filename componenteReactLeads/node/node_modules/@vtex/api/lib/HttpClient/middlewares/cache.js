"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const constants_1 = require("../../constants");
const constants_2 = require("./../../constants");
const RANGE_HEADER_QS_KEY = '__range_header';
const cacheableStatusCodes = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]; // https://tools.ietf.org/html/rfc7231#section-6.1
exports.cacheKey = (config) => {
    const { baseURL = '', url = '', params, headers } = config;
    const locale = headers[constants_2.LOCALE_HEADER];
    const fullURL = [baseURL, url].filter(str => str).join('/');
    const urlObject = new url_1.URL(fullURL);
    if (headers && headers.range) {
        urlObject.searchParams.append(RANGE_HEADER_QS_KEY, headers.range);
    }
    if (params) {
        for (const [key, value] of Object.entries(params)) {
            urlObject.searchParams.append(key, value);
        }
    }
    // Replace forward slashes with backwards slashes for disk cache legibility
    const encodedPath = `${locale}/${urlObject.pathname}${urlObject.search}`.replace(/\//g, '\\\\');
    // Add hostname as top level directory on disk cache
    return `${urlObject.hostname}/${encodedPath}`;
};
const parseCacheHeaders = (headers) => {
    const { 'cache-control': cacheControl = '', etag, age: ageStr } = headers;
    const cacheDirectives = cacheControl.split(',').map(d => d.trim());
    const maxAgeDirective = cacheDirectives.find(d => d.startsWith('max-age'));
    const [, maxAgeStr] = maxAgeDirective ? maxAgeDirective.split('=') : [null, null];
    const maxAge = maxAgeStr ? parseInt(maxAgeStr, 10) : 0;
    const age = ageStr ? parseInt(ageStr, 10) : 0;
    return {
        age,
        etag,
        maxAge,
        noCache: cacheDirectives.indexOf('no-cache') !== -1,
        noStore: cacheDirectives.indexOf('no-store') !== -1,
    };
};
function isLocallyCacheable(arg, type) {
    return arg && !!arg.cacheable
        && (arg.cacheable === type || arg.cacheable === CacheType.Any || type === CacheType.Any);
}
exports.isLocallyCacheable = isLocallyCacheable;
const addNotModified = (validateStatus) => (status) => validateStatus(status) || status === 304;
var CacheType;
(function (CacheType) {
    CacheType[CacheType["None"] = 0] = "None";
    CacheType[CacheType["Memory"] = 1] = "Memory";
    CacheType[CacheType["Disk"] = 2] = "Disk";
    CacheType[CacheType["Any"] = 3] = "Any";
})(CacheType = exports.CacheType || (exports.CacheType = {}));
exports.cacheMiddleware = ({ type, storage }) => {
    return async (ctx, next) => {
        if (!isLocallyCacheable(ctx.config, type)) {
            return await next();
        }
        const key = exports.cacheKey(ctx.config);
        const segmentToken = ctx.config.headers[constants_1.SEGMENT_HEADER];
        const keyWithSegment = key + segmentToken;
        const cacheHasWithSegment = await storage.has(keyWithSegment);
        const cached = cacheHasWithSegment ? await storage.get(keyWithSegment) : await storage.get(key);
        if (cached) {
            const { etag: cachedEtag, response, expiration, responseType, responseEncoding } = cached;
            if (expiration > Date.now() && response) {
                if (type === CacheType.Disk && responseType === 'arraybuffer') {
                    response.data = Buffer.from(response.data, responseEncoding);
                }
                ctx.response = response;
                ctx.cacheHit = {
                    memory: 1,
                    revalidated: 0,
                    router: 0,
                };
                return;
            }
            const validateStatus = addNotModified(ctx.config.validateStatus);
            if (cachedEtag && validateStatus(response.status)) {
                ctx.config.headers['if-none-match'] = cachedEtag;
                ctx.config.validateStatus = validateStatus;
            }
        }
        await next();
        if (!ctx.response) {
            return;
        }
        const revalidated = ctx.response.status === 304;
        if (revalidated && cached) {
            ctx.response = cached.response;
            ctx.cacheHit = {
                memory: 1,
                revalidated: 1,
                router: 0,
            };
        }
        const { data, headers, status } = ctx.response;
        const { age, etag, maxAge: headerMaxAge, noStore, noCache } = parseCacheHeaders(headers);
        const { forceMaxAge } = ctx.config;
        const maxAge = forceMaxAge && cacheableStatusCodes.includes(status) ? Math.max(forceMaxAge, headerMaxAge) : headerMaxAge;
        // Indicates this should NOT be cached and this request will not be considered a miss.
        if (!forceMaxAge && (noStore || (noCache && !etag))) {
            return;
        }
        const shouldCache = maxAge || etag;
        const varySession = ctx.response.headers.vary && ctx.response.headers.vary.includes(constants_1.SESSION_HEADER);
        if (shouldCache && !varySession) {
            const { responseType, responseEncoding } = ctx.config;
            const currentAge = revalidated ? 0 : age;
            const varySegment = ctx.response.headers.vary && ctx.response.headers.vary.includes(constants_1.SEGMENT_HEADER);
            const setKey = varySegment ? keyWithSegment : key;
            const cacheableData = type === CacheType.Disk && responseType === 'arraybuffer'
                ? data.toString(responseEncoding)
                : data;
            await storage.set(setKey, {
                etag,
                expiration: Date.now() + (maxAge - currentAge) * 1000,
                response: { data: cacheableData, headers, status },
                responseEncoding,
                responseType,
            });
            return;
        }
    };
};
