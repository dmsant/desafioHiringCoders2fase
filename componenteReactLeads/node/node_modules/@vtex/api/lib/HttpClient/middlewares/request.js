"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const agentkeepalive_1 = __importDefault(require("agentkeepalive"));
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importStar(require("axios-retry"));
const qs_1 = require("qs");
const ramda_1 = require("ramda");
const renameBy_1 = require("../../utils/renameBy");
const retry_1 = require("../../utils/retry");
const httpAgent = new agentkeepalive_1.default({
    freeSocketTimeout: 15 * 1000,
    keepAlive: true,
    maxFreeSockets: 50,
});
const http = axios_1.default.create({
    httpAgent,
});
axios_retry_1.default(http, {
    retries: 0,
    retryCondition: retry_1.isAbortedOrNetworkErrorOrRouterTimeout,
    retryDelay: axios_retry_1.exponentialDelay,
    shouldResetTimeout: true,
});
const paramsSerializer = (params) => {
    return qs_1.stringify(params, { arrayFormat: 'repeat' });
};
exports.defaultsMiddleware = (baseURL, rawHeaders, params, timeout, retries, verbose) => {
    const countByMetric = {};
    const headers = renameBy_1.renameBy(ramda_1.toLower, rawHeaders);
    return async (ctx, next) => {
        ctx.config = Object.assign({ 'axios-retry': retries ? { retries } : undefined, baseURL, maxRedirects: 0, timeout, validateStatus: status => (status >= 200 && status < 300), verbose }, ctx.config, { headers: Object.assign({}, headers, renameBy_1.renameBy(ramda_1.toLower, ctx.config.headers)), params: Object.assign({}, params, ctx.config.params), paramsSerializer });
        if (ctx.config.verbose && ctx.config.metric) {
            const current = countByMetric[ctx.config.metric];
            countByMetric[ctx.config.metric] = (current || 0) + 1;
            ctx.config.count = countByMetric[ctx.config.metric];
            ctx.config.label = `${ctx.config.metric}#${ctx.config.count}`;
        }
        await next();
    };
};
const ROUTER_CACHE_KEY = 'x-router-cache';
const ROUTER_CACHE_HIT = 'HIT';
const ROUTER_CACHE_REVALIDATED = 'REVALIDATED';
const ROUTER_CACHE_KEY_PATH = ['response', 'headers', ROUTER_CACHE_KEY];
const ROUTER_RESPONSE_STATUS_PATH = ['response', 'status'];
exports.routerCacheMiddleware = async (ctx, next) => {
    await next();
    const routerCacheHit = ramda_1.path(ROUTER_CACHE_KEY_PATH, ctx);
    const status = ramda_1.path(ROUTER_RESPONSE_STATUS_PATH, ctx);
    if (routerCacheHit === ROUTER_CACHE_HIT || (routerCacheHit === ROUTER_CACHE_REVALIDATED && status !== 304)) {
        ctx.cacheHit = Object.assign({ memory: 0, revalidated: 0 }, ctx.cacheHit, { router: 1 });
    }
};
exports.requestMiddleware = (limit) => async (ctx, next) => {
    const makeRequest = () => http.request(ctx.config);
    ctx.response = await (limit ? limit(makeRequest) : makeRequest());
};
function countPerOrigin(obj) {
    try {
        return ramda_1.mapObjIndexed(val => val.length, obj);
    }
    catch (_) {
        return {};
    }
}
function httpAgentStats() {
    const socketsPerOrigin = countPerOrigin(httpAgent.sockets);
    const sockets = ramda_1.sum(ramda_1.values(socketsPerOrigin));
    const freeSocketsPerOrigin = countPerOrigin(httpAgent.freeSockets);
    const freeSockets = ramda_1.sum(ramda_1.values(freeSocketsPerOrigin));
    const pendingRequestsPerOrigin = countPerOrigin(httpAgent.requests);
    const pendingRequests = ramda_1.sum(ramda_1.values(pendingRequestsPerOrigin));
    return {
        freeSockets,
        freeSocketsPerOrigin,
        pendingRequests,
        pendingRequestsPerOrigin,
        sockets,
        socketsPerOrigin,
    };
}
exports.httpAgentStats = httpAgentStats;
