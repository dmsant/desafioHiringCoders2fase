"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const archiver_1 = __importDefault(require("archiver"));
const HttpClient_1 = require("../HttpClient");
const cache_1 = require("../HttpClient/middlewares/cache");
const routes = {
    Availability: (app) => `${routes.Builder}/availability/${app}`,
    Builder: '/_v/builder/0',
    Clean: (app) => `${routes.Builder}/clean/${app}`,
    Link: (app) => `${routes.Builder}/link/${app}`,
    PinnedDependencies: () => `${routes.Builder}/pinneddeps`,
    Publish: (app) => `${routes.Builder}/publish/${app}`,
    Relink: (app) => `${routes.Builder}/relink/${app}`,
    Test: (app) => `${routes.Builder}/test/${app}`,
};
class Builder extends HttpClient_1.AppClient {
    constructor(ioContext, opts) {
        super('vtex.builder-hub@0.x', ioContext, opts);
        this.availability = async (app, hintIndex) => {
            const stickyHint = hintIndex === undefined || hintIndex === null ?
                `request:${this.context.account}:${this.context.workspace}:${app}` :
                `request:${this.context.account}:${this.context.workspace}:${app}:${hintIndex}`;
            const headers = {
                'Content-Type': 'application/json',
                'x-vtex-sticky-host': stickyHint,
            };
            const metric = 'bh-availability';
            const { data: { availability }, headers: { 'x-vtex-sticky-host': host }, } = await this.http.getRaw(routes.Availability(app), { headers, metric, cacheable: cache_1.CacheType.None });
            const { hostname, score } = availability;
            return { host, hostname, score };
        };
        this.clean = (app) => {
            const headers = Object.assign({ 'Content-Type': 'application/json' }, this.stickyHost && { 'x-vtex-sticky-host': this.stickyHost });
            const metric = 'bh-clean';
            return this.http.post(routes.Clean(app), { headers, metric });
        };
        this.getPinnedDependencies = () => {
            return this.http.get(routes.PinnedDependencies());
        };
        this.linkApp = (app, files, zipOptions = { sticky: true }, params = {}) => {
            return this.zipAndSend(routes.Link(app), app, files, zipOptions, params);
        };
        this.publishApp = (app, files, zipOptions = { sticky: true }, params = {}) => {
            return this.zipAndSend(routes.Publish(app), app, files, zipOptions, params);
        };
        this.relinkApp = (app, changes, params = {}) => {
            const headers = Object.assign({ 'Content-Type': 'application/json' }, this.stickyHost && { 'x-vtex-sticky-host': this.stickyHost });
            const metric = 'bh-relink';
            return this.http.put(routes.Relink(app), changes, { headers, metric, params });
        };
        this.testApp = (app, files, zipOptions = { sticky: true }, params = {}) => {
            return this.zipAndSend(routes.Test(app), app, files, zipOptions, params);
        };
        this.zipAndSend = async (route, app, files, { tag, sticky, stickyHint, zlib } = {}, requestParams = {}) => {
            if (!(files[0] && files[0].path && files[0].content)) {
                throw new Error('Argument files must be an array of {path, content}, where content can be a String, a Buffer or a ReadableStream.');
            }
            const indexOfManifest = files.findIndex(({ path }) => path === 'manifest.json');
            if (indexOfManifest === -1) {
                throw new Error('No manifest.json file found in files.');
            }
            const zip = archiver_1.default('zip', { zlib });
            // Throw stream errors so they reject the promise chain.
            zip.on('error', (e) => {
                throw e;
            });
            const hint = stickyHint || `request:${this.context.account}:${this.context.workspace}:${app}`;
            const metric = 'bh-zip-send';
            const params = tag ? Object.assign({}, requestParams, { tag }) : requestParams;
            const request = this.http.postRaw(route, zip, {
                headers: Object.assign({ 'Content-Type': 'application/octet-stream' }, sticky && { 'x-vtex-sticky-host': this.stickyHost || hint }),
                metric,
                params,
            });
            files.forEach(({ content, path }) => zip.append(content, { name: path }));
            const finalize = zip.finalize();
            const [response] = await Promise.all([request, finalize]);
            const { data, headers: { 'x-vtex-sticky-host': host } } = response;
            this.stickyHost = host;
            return data;
        };
    }
}
exports.Builder = Builder;
