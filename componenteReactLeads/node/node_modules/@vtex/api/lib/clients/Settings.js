"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const ramda_1 = require("ramda");
const HttpClient_1 = require("../HttpClient");
const app_1 = require("../utils/app");
const LINKED_ROUTE = 'linked';
const dependsOnApp = (appAtMajor) => (a) => {
    const [name, major] = appAtMajor.split('@');
    const version = a._resolvedDependencies[name];
    if (!version) {
        return false;
    }
    const [depMajor] = version.split('.');
    return major === depMajor;
};
const joinIds = ramda_1.join('');
const containsLinks = ramda_1.any(app_1.isLinkedApp);
class Settings extends HttpClient_1.AppClient {
    constructor(context, options) {
        super('vtex.settings-server@0.x', context, options);
    }
    getFilteredDependencies(appAtMajor, dependencies) {
        const depends = dependsOnApp(appAtMajor);
        return ramda_1.filter(depends, dependencies);
    }
    getDependenciesHash(dependencies) {
        const dependingApps = ramda_1.pluck('id', dependencies);
        return crypto_1.createHash('md5').update(joinIds(dependingApps)).digest('hex');
    }
    async getSettings(dependencies, appAtMajor, params) {
        const filtered = this.getFilteredDependencies(appAtMajor, dependencies);
        // Settings server exposes a smartCache-enabled route for when the workspace contains links.
        const lastSegment = containsLinks(filtered)
            ? LINKED_ROUTE
            : this.getDependenciesHash(filtered);
        return this.http.get(`/settings/${appAtMajor}/${lastSegment}`, {
            inflightKey: HttpClient_1.inflightUrlWithQuery,
            metric: 'settings-get',
            params,
        });
    }
}
exports.Settings = Settings;
