/// <reference types="node" />
import { IncomingMessage } from 'http';
import { Readable } from 'stream';
import { InfraClient, InstanceOptions } from '../HttpClient';
import { BucketMetadata, FileListItem } from '../responses';
import { IOContext } from '../service/typings';
export declare class VBase extends InfraClient {
    constructor(context: IOContext, options?: InstanceOptions);
    getBucket: (bucket: string) => Promise<BucketMetadata>;
    resetBucket: (bucket: string) => Promise<import("../HttpClient").IOResponse<void>>;
    listFiles: (bucket: string, opts?: string | VBaseOptions | undefined) => Promise<BucketFileList>;
    getFile: (bucket: string, path: string) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getJSON: <T>(bucket: string, path: string, nullIfNotFound?: boolean | undefined, conflictsResolver?: ConflictsResolver | undefined) => Promise<{} | T>;
    getFileStream: (bucket: string, path: string) => Promise<IncomingMessage>;
    saveFile: (bucket: string, path: string, stream: Readable, gzip?: boolean, ttl?: number | undefined) => Promise<void>;
    getFileMetadata: (bucket: string, path: string) => Promise<import("../HttpClient").IOResponse<void>>;
    saveJSON: <T>(bucket: string, path: string, data: T) => Promise<void>;
    saveZippedContent: (bucket: string, path: string, stream: Readable) => Promise<void>;
    deleteFile: (bucket: string, path: string) => Promise<import("../HttpClient").IOResponse<void>>;
    getConflicts: <T>(bucket: string) => Promise<T>;
    resolveConflict: <T>(bucket: string, path: string, content: any) => Promise<T>;
    private saveContent;
}
export interface BucketFileList {
    data: FileListItem[];
    next: string;
    smartCacheHeaders: any;
}
export interface VBaseOptions {
    prefix?: string;
    _next?: string;
    _limit?: number;
}
export interface VBaseSaveOptions {
    gzip?: boolean;
    unzip?: boolean;
    ttl?: number;
}
export interface VBaseConflictData {
    path: string;
    base: VBaseConflict;
    master: VBaseConflict;
    mine: VBaseConflict;
}
export interface VBaseConflict {
    contentOmitted: boolean;
    deleted: boolean;
    mimeType: string;
    parsedContent?: any;
    content: string;
}
export interface ConflictsResolver {
    resolve: () => {};
}
