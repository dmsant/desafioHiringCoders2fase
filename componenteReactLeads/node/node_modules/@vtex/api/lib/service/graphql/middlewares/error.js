"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const Logger_1 = require("../../../clients/Logger");
const RequestCancelledError_1 = require("../../../errors/RequestCancelledError");
const array_1 = require("../utils/array");
const pathname_1 = require("../utils/pathname");
const CACHE_CONTROL_HEADER = 'cache-control';
const META_HEADER = 'x-vtex-meta';
const ETAG_HEADER = 'etag';
const TWO_SECONDS_S = 2;
const arrayHasError = ramda_1.any(ramda_1.has('errors'));
const filterErrors = ramda_1.filter(ramda_1.has('errors'));
const chainErrors = ramda_1.chain(ramda_1.prop('errors'));
const hasError = ramda_1.compose(arrayHasError, array_1.toArray);
const parseError = ramda_1.compose(chainErrors, filterErrors, array_1.toArray);
const parseErrorResponse = (response) => {
    if (hasError(response)) {
        return parseError(response);
    }
    return null;
};
async function graphqlError(ctx, next) {
    const { vtex: { production, route: { id, }, }, } = ctx;
    let graphQLErrors = null;
    try {
        await next();
        graphQLErrors = parseErrorResponse(ctx.graphql.graphqlResponse || {});
    }
    catch (e) {
        if (e.code === RequestCancelledError_1.cancelledErrorCode) {
            ctx.status = RequestCancelledError_1.cancelledRequestStatus;
            return;
        }
        const formatError = ctx.graphql.formatters.formatError;
        if (e.isGraphQLError) {
            const response = JSON.parse(e.message);
            graphQLErrors = parseError(response);
            ctx.body = response;
        }
        else {
            graphQLErrors = [formatError(e)];
            ctx.body = { errors: graphQLErrors };
        }
        // Add response
        ctx.status = e.statusCode || 500;
        if (e.headers) {
            ctx.set(e.headers);
        }
    }
    finally {
        if (graphQLErrors) {
            const uniqueErrors = ramda_1.uniqBy((e) => {
                if (e.extensions.exception && e.extensions.exception.request) {
                    return e.extensions.exception.request.path;
                }
                return e;
            }, graphQLErrors);
            // Reduce size of `variables` prop in the errors.
            ramda_1.map((e) => {
                if (e.query && e.query.variables) {
                    const stringifiedVariables = JSON.stringify(e.query.variables);
                    e.query.variables = stringifiedVariables.length <= 1024 ? stringifiedVariables : '[variables too long]';
                }
            }, uniqueErrors);
            console.error(`[node-vtex-api graphql errors] total=${graphQLErrors.length} unique=${uniqueErrors.length}`, uniqueErrors);
            ctx.graphql.status = 'error';
            // Do not generate etag for errors
            ctx.remove(META_HEADER);
            ctx.remove(ETAG_HEADER);
            // In production errors, add two second cache
            if (production) {
                ctx.set(CACHE_CONTROL_HEADER, `public, max-age=${TWO_SECONDS_S}`);
            }
            else {
                ctx.set(CACHE_CONTROL_HEADER, `no-cache, no-store`);
            }
            // Log each error to splunk individually
            ramda_1.forEach((err) => {
                // Prevent logging cancellation error (it's not an error)
                if (err.extensions.exception && err.extensions.exception.code === RequestCancelledError_1.cancelledErrorCode) {
                    return;
                }
                // Add pathName to each error
                if (err.path) {
                    err.pathName = pathname_1.generatePathName(err.path);
                }
                const log = Object.assign({}, err, { routeId: id });
                // Grab level from originalError, default to "error" level.
                let level = err.extensions.exception && err.extensions.exception.level;
                if (!level || !(level === Logger_1.LogLevel.Error || level === Logger_1.LogLevel.Warn)) {
                    level = Logger_1.LogLevel.Error;
                }
                ctx.vtex.logger.log(log, level);
            }, uniqueErrors);
            // Expose graphQLErrors with pathNames to timings middleware
            ctx.graphql.graphQLErrors = uniqueErrors;
        }
        else {
            ctx.graphql.status = 'success';
        }
    }
}
exports.graphqlError = graphqlError;
