"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const apollo_server_errors_1 = require("apollo-server-errors");
const ramda_1 = require("ramda");
const error_1 = require("../../../utils/error");
const ERROR_FIELD_WHITELIST = ['message', 'path', 'stack', 'extensions', 'statusCode', 'name', 'headers', 'originalError', 'code'];
// formatError overrides the default option in runHttpQuery, which
// does not keep track of the error stack. All non-enumerable
// properties of Error (including stack) need to be returned
// explicitly, otherwise will not show up after a JSON.stringify call
const createFormatError = (details) => (error) => {
    const formattedError = ramda_1.pick(ERROR_FIELD_WHITELIST, error);
    if (!formattedError.extensions) {
        formattedError.extensions = {
            code: 'INTERNAL_SERVER_ERROR',
        };
    }
    if (formattedError.originalError) {
        formattedError.originalError = error_1.cleanError(formattedError.originalError);
        if (formattedError.stack === formattedError.originalError.stack) {
            delete formattedError.originalError.stack;
        }
        if (!formattedError.extensions.exception) {
            formattedError.extensions.exception = Object.assign({ message: formattedError.originalError.message, name: formattedError.originalError.name, stack: formattedError.originalError.stack }, formattedError.originalError);
        }
        else {
            const extendedException = Object.assign({ message: formattedError.originalError.message, name: formattedError.originalError.name, stack: formattedError.originalError.stack }, formattedError.originalError, formattedError.extensions.exception);
            formattedError.extensions.exception = error_1.cleanError(extendedException);
        }
        // Make originalError not enumerable to prevent duplicated log and response information
        Object.defineProperty(formattedError, 'originalError', { enumerable: false });
    }
    Object.assign(formattedError, details);
    return formattedError;
};
const createFormatResponse = (formatter) => (response) => {
    const { errors = null } = response || {};
    return Object.assign({}, response, { errors: Array.isArray(errors) ? apollo_server_errors_1.formatApolloErrors(errors, { formatter }) : undefined });
};
async function createFormatters(ctx, next) {
    const { headers: { 'x-forwarded-host': forwardedHost, 'x-forwarded-proto': forwardedProto, 'x-vtex-platform': platform, }, vtex: { operationId, requestId, }, } = ctx;
    // Do not log variables for file uploads
    const variables = ctx.request.is('multipart/form-data')
        ? '[GraphQL Upload]'
        : ctx.graphql.query && ctx.graphql.query.variables;
    const query = Object.assign({}, ctx.graphql.query, { variables });
    const details = {
        forwardedHost,
        forwardedProto,
        operationId,
        platform,
        query,
        requestId,
    };
    const formatError = createFormatError(details);
    const formatResponse = createFormatResponse(formatError);
    ctx.graphql.formatters = {
        formatError,
        formatResponse,
    };
    await next();
}
exports.createFormatters = createFormatters;
