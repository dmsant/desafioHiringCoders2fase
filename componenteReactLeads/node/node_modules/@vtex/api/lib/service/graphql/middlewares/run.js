"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const apollo_server_core_1 = require("apollo-server-core");
const caches_1 = require("../../../caches");
const maxAgeEnum_1 = require("../utils/maxAgeEnum");
exports.graphqlRuntimeCacheStorage = new caches_1.LRUCache({
    max: 100,
});
const persistedQueries = {
    cache: exports.graphqlRuntimeCacheStorage,
};
const linked = !!process.env.VTEX_APP_LINK;
async function run(ctx, next) {
    const { method, graphql, request, } = ctx;
    const { dataSources, formatters, query, schema, } = graphql;
    const { formatError, formatResponse, } = formatters;
    // We don't want resolvers to have access to the GraphQL context,
    // so we delete it here and restore it after execution.
    delete ctx.graphql;
    try {
        const { graphqlResponse, responseInit } = await apollo_server_core_1.runHttpQuery([], {
            method,
            options: {
                cacheControl: {
                    calculateHttpHeaders: true,
                    defaultMaxAge: maxAgeEnum_1.defaultMaxAgeFromCtx(ctx),
                    stripFormattedExtensions: false,
                },
                context: ctx,
                dataSources,
                debug: linked,
                documentStore: exports.graphqlRuntimeCacheStorage,
                formatError,
                formatResponse,
                parseOptions: {
                    noLocation: !linked,
                },
                persistedQueries,
                schema,
                tracing: linked,
            },
            query: query,
            request,
        });
        ctx.graphql = graphql;
        ctx.graphql.responseInit = responseInit;
        ctx.graphql.graphqlResponse = JSON.parse(graphqlResponse);
    }
    catch (err) {
        ctx.graphql = graphql;
        throw err;
    }
    await next();
}
exports.run = run;
