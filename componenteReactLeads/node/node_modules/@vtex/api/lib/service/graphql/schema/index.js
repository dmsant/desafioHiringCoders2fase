"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const graphql_tools_1 = require("graphql-tools");
const ramda_1 = require("ramda");
const messagesLoader_1 = require("./messagesLoader");
const schemaDirectives_1 = require("./schemaDirectives");
const typeDefs_1 = require("./typeDefs");
const cache = {
    executableSchema: null,
    schemaMetaData: null,
    typeDefs: null,
};
let appTypeDefs;
try {
    appTypeDefs = fs_extra_1.readFileSync('./service/schema.graphql', 'utf8');
    // tslint:disable-next-line:no-empty
}
catch (err) { }
exports.makeSchema = (ctx) => {
    const { graphql: { resolvers: appResolvers, schemaDirectives: appDirectives, }, clients: { segment }, vtex: { locale }, } = ctx;
    if (cache.executableSchema) {
        return cache.executableSchema;
    }
    const schemaMetaData = extractSchemaMetaData(appTypeDefs);
    // The target translation locale is only necessary if this GraphQL app uses the `IOMessage` resolver.
    const getLocaleTo = async () => {
        if (locale) {
            return locale;
        }
        const { cultureInfo } = await segment.getSegment();
        return cultureInfo;
    };
    const resolverContext = {
        getLocaleTo,
        translationsLoader: messagesLoader_1.messagesLoader(ctx.clients),
    };
    const executableSchema = graphql_tools_1.makeExecutableSchema({
        resolvers: Object.assign({}, appResolvers, typeDefs_1.nativeResolvers(resolverContext)),
        schemaDirectives: Object.assign({}, appDirectives, schemaDirectives_1.nativeSchemaDirectives),
        typeDefs: getOrSetTypeDefs(schemaMetaData),
    });
    if (isSchemaCacheable(schemaMetaData)) {
        cache.executableSchema = executableSchema;
    }
    return executableSchema;
};
const getOrSetTypeDefs = (schemaMetaData) => {
    if (!cache.typeDefs) {
        cache.typeDefs = [
            appTypeDefs,
            typeDefs_1.nativeTypeDefs(schemaMetaData),
        ].join('\n\n');
    }
    return cache.typeDefs;
};
const hasScalar = (typeDefs) => (scalar) => new RegExp(`scalar(\\s)+${scalar}(\\s\\n)+`).test(typeDefs);
const extractSchemaMetaData = (typeDefs) => {
    if (!cache.schemaMetaData) {
        const scalars = ramda_1.keys(typeDefs_1.scalarResolversMap);
        const scalarsPresentInSchema = ramda_1.map(hasScalar(typeDefs), scalars);
        cache.schemaMetaData = ramda_1.zipObj(scalars, scalarsPresentInSchema);
    }
    return cache.schemaMetaData;
};
const isSchemaCacheable = (schemaMetaData) => !ramda_1.any(scalar => schemaMetaData[scalar], typeDefs_1.shouldNotCacheWhenSchemaHas);
