"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bluebird_1 = require("bluebird");
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const messagesLoader_1 = require("../messagesLoader");
class Translatable extends graphql_tools_1.SchemaDirectiveVisitor {
    visitFieldDefinition(field) {
        const { resolve = graphql_1.defaultFieldResolver } = field;
        const { behavior = 'FULL' } = this.args;
        field.resolve = async (root, args, context, info) => {
            const { clients: { segment }, clients, vtex: { logger } } = context;
            if (Math.random() < 0.1) {
                logger.warn(`Translatable directive in use by: ${context.vtex.account} (Operation Id: ${context.vtex.operationId})`);
            }
            if (!context.loaders || !context.loaders.messages) {
                context.loaders = Object.assign({}, context.loaders, { messages: messagesLoader_1.messagesLoader(clients) });
            }
            const response = await resolve(root, args, context, info);
            const handler = handleSingleString(context, behavior);
            return Array.isArray(response) ? await bluebird_1.map(response, handler) : await handler(response);
        };
    }
}
exports.Translatable = Translatable;
const handleSingleString = (context, behavior) => async (response) => {
    // Messages only knows how to process non empty strings.
    if ((typeof response !== 'string' && typeof response !== 'object') || Array.isArray(response) || response == null) {
        return response;
    }
    const resObj = typeof response === 'string'
        ? {
            content: response,
            description: '',
            from: undefined,
            id: response,
        }
        : response;
    const { content, from, id } = resObj;
    const { clients: { segment }, vtex: { locale } } = context;
    const to = locale != null
        ? locale
        : (await segment.getSegment()).cultureInfo;
    if (content == null && id == null) {
        throw new Error(`@translatable directive needs a content or id to translate, but received ${JSON.stringify(response)}`);
    }
    // If the message is already in the target locale, return the content.
    if (!to || from === to) {
        return content;
    }
    return context.loaders.messages.load(Object.assign({}, resObj, { behavior,
        from,
        to }));
};
