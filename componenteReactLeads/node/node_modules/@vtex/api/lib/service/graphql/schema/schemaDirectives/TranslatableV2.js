"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bluebird_1 = require("bluebird");
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const ramda_1 = require("ramda");
const messagesLoaderV2_1 = require("../messagesLoaderV2");
const CONTEXT_REGEX = /\(\(\((?<context>(.)*)\)\)\)/;
const FROM_REGEX = /\<\<\<(?<from>(.)*)\>\>\>/;
const CONTENT_REGEX = /\(\(\((?<context>(.)*)\)\)\)|\<\<\<(?<from>(.)*)\>\>\>/g;
class TranslatableV2 extends graphql_tools_1.SchemaDirectiveVisitor {
    visitFieldDefinition(field) {
        const { resolve = graphql_1.defaultFieldResolver } = field;
        const { behavior = 'FULL', withAppsMetaInfo = false } = this.args;
        field.resolve = async (root, args, ctx, info) => {
            if (!ctx.loaders || !ctx.loaders.messagesV2) {
                ctx.loaders = Object.assign({}, ctx.loaders, { messagesV2: messagesLoaderV2_1.messagesLoaderV2(ctx.clients) });
            }
            const response = await resolve(root, args, ctx, info);
            const { vtex, loaders: { messagesV2 } } = ctx;
            const handler = handleSingleString(vtex, messagesV2, behavior, withAppsMetaInfo);
            return Array.isArray(response) ? await bluebird_1.map(response, handler) : await handler(response);
        };
    }
}
exports.TranslatableV2 = TranslatableV2;
exports.parseTranslatableStringV2 = (rawMessage) => {
    const context = ramda_1.path(['groups', 'context'], rawMessage.match(CONTEXT_REGEX) || {});
    const from = ramda_1.path(['groups', 'from'], rawMessage.match(FROM_REGEX) || {});
    const content = rawMessage.replace(CONTENT_REGEX, '');
    return {
        content: content && content.trim(),
        context: context && context.trim(),
        from: from && from.trim(),
    };
};
exports.formatTranslatableStringV2 = ({ from, content, context }) => `${content} ${context ? `(((${context})))` : ''} ${from ? `<<<${from}>>>` : ''}`;
const handleSingleString = (ctx, messagesV2, behavior, withAppsMetaInfo) => async (rawMessage) => {
    // Messages only knows how to process non empty strings.
    if (rawMessage == null) {
        return rawMessage;
    }
    const { content, context, from: maybeFrom } = exports.parseTranslatableStringV2(rawMessage);
    const { locale: to, tenant } = ctx;
    if (content == null) {
        throw new Error(`@translatableV2 directive needs a content to translate, but received ${JSON.stringify(rawMessage)}`);
    }
    if (to == null) {
        throw new Error('@translatableV2 directive needs the locale variable available in IOContext. You can do this by either setting \`ctx.vtex.locale\` directly or calling this app with \`x-vtex-locale\` header');
    }
    const from = maybeFrom || (tenant && tenant.locale);
    if (from == null) {
        throw new Error('@translatableV2 directive needs a source language to translate from. You can do this by either setting \`ctx.vtex.tenant\` variable, call this app with the header \`x-vtex-tenant\` or format the string with the \`formatTranslatableStringV2\` function with the \`from\` option set');
    }
    // If the message is already in the target locale, return the content.
    if (!to || from === to) {
        return content;
    }
    return messagesV2.load({
        behavior,
        content,
        context,
        from,
        to,
        withAppsMetaInfo,
    });
};
