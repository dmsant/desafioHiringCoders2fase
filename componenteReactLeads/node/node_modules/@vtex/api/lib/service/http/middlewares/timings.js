"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const status_1 = require("../../../utils/status");
const time_1 = require("../../../utils/time");
const APP_ELAPSED_TIME_LOCATOR = time_1.shrinkTimings(time_1.formatTimingName({
    hopNumber: 0,
    source: process.env.VTEX_APP_NAME,
    target: '',
}));
const formatDate = (date) => chalk_1.default.dim('[' + date.toISOString().split('T')[1] + ']');
const formatStatus = (status) => status >= 500 ? chalk_1.default.red(status.toString()) : (status >= 200 && status < 300 ? chalk_1.default.green(status.toString()) : status);
const formatMillis = (millis) => millis >= 500 ? chalk_1.default.red(millis.toString()) : millis >= 200 ? chalk_1.default.yellow(millis.toString()) : chalk_1.default.green(millis.toString());
const log = ({ vtex: { account, workspace, route: { id } }, path, method, status }, millis) => `${formatDate(new Date())}\t${account}/${workspace}:${id}\t${formatStatus(status)}\t${method}\t${path}\t${formatMillis(millis)} ms`;
async function timings(ctx, next) {
    // Errors will be caught by the next middleware so we don't have to catch.
    await next();
    const { status: statusCode, vtex: { route: { id } }, timings: { total } } = ctx;
    const totalMillis = time_1.hrToMillis(total);
    console.log(log(ctx, totalMillis));
    const status = status_1.statusLabel(statusCode);
    // Only batch successful responses so metrics don't consider errors
    metrics.batch(`http-handler-${id}`, status === 'success' ? total : undefined, { [status]: 1 });
    if (ctx.serverTiming) {
        ctx.serverTiming[APP_ELAPSED_TIME_LOCATOR] = `${totalMillis}`;
        ctx.set('Server-Timing', time_1.reduceTimings(ctx.serverTiming));
    }
}
exports.timings = timings;
